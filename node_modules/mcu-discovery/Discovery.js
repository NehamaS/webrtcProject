"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const util = require('util');
const net = require('net');
const ip = require('ip');
const consul = require('consul')({ host: process.env.EXT_IP || "consul", promisify: true });
const request = __importStar(require("request"));
const dns = __importStar(require("dns"));
const address = process.env.THBIND || ip.address();
const rrtype = net.isIPv6(address) ? "AAAA" : "A";
const MG_THRIFT = 9090;
const MG_HTTP = 9160;
const SIP_THRIFT = 9096;
const SIP_HTTP = 9196;
const SIP_NOTIFY_THRIFT = 9098;
const SIP_NOTIFY_HTTP = 9198;
const STATS_THRIFT = 7029;
const STATS_HTTP = 7028;
const MONITOR_THRIFT = 3205;
const MONITOR_HTTP = 3305;
const MONITOR_HTTPS = 3443;
const RECORDER_HTTP = 3000;
const MEDIA_THRIFT = 7711;
const MEDIA_HTTP = 7712;
const ETCD_HTTP = 2379;
var ServiceType;
(function (ServiceType) {
    ServiceType["SIP_GATEWAY"] = "sipGw";
    ServiceType["SIP_GATEWAY_NOTIFY"] = "sipGwNotify";
    ServiceType["MEDIA_GATEWAY"] = "mediaGw";
    ServiceType["MEDIA_SERVER"] = "mediaServer";
    ServiceType["MCU_STATS_SERVICE"] = "stats";
    ServiceType["MCU_MONITOR_SERVICE"] = "monitor";
    ServiceType["MCU_RECORDER_CONTROLLER"] = "recorder";
    ServiceType["ETCD"] = "etcd";
})(ServiceType = exports.ServiceType || (exports.ServiceType = {}));
const mediaGwPorts = {
    "thriftPort": parseInt(process.env.MG_THRIFT) || MG_THRIFT,
    "httpPort": parseInt(process.env.MG_HTTP) || MG_HTTP
};
const sipGwPorts = {
    "thriftPort": parseInt(process.env.SIP_THRIFT) || SIP_THRIFT,
    "httpPort": parseInt(process.env.SIP_HTTP) || SIP_HTTP
};
const sipNotifyGwPorts = {
    "thriftPort": parseInt(process.env.SIP_NOTIFY_THRIFT) || SIP_NOTIFY_THRIFT,
    "httpPort": parseInt(process.env.SIP_NOTIFY_HTTP) || SIP_NOTIFY_HTTP
};
const statsPorts = {
    "thriftPort": parseInt(process.env.STATS_THRIFT) || STATS_THRIFT,
    "httpPort": parseInt(process.env.STATS_HTTP) || STATS_HTTP,
};
const monitorPorts = {
    "thriftPort": parseInt(process.env.MONITOR_THRIFT) || MONITOR_THRIFT,
    "httpPort": parseInt(process.env.MONITOR_HTTP) || MONITOR_HTTP,
    "httpsPort": parseInt(process.env.MONITOR_HTTPS) || MONITOR_HTTPS
};
const recorderPorts = {
    "httpPort": parseInt(process.env.RECORDER_HTTP) || RECORDER_HTTP
};
const mediaPorts = {
    "httpPort": parseInt(process.env.RECORDER_HTTP) || RECORDER_HTTP,
    "thriftPort": parseInt(process.env.MEDIA_THRIFT) || MEDIA_THRIFT
};
const etcdPorts = {
    "httpPort": parseInt(process.env.ETCD_HTTP) || ETCD_HTTP,
    "thriftPort": -1
};
class Discovery {
    constructor(discoveryType, logger) {
        this.discoveryType = discoveryType;
        this.logger = logger;
        this.getSrvThriftPort = (tags) => {
            return parseInt(this.getSrvTagValue(tags, "thrift"));
        };
        this.getSrvTagValue = (tags, tagPrefix) => {
            if (tags && (tags.length > 0)) {
                let tag = tags.filter(httpPort => httpPort.startsWith(tagPrefix + "-"));
                if (tag && (tag.length > 0)) {
                    return tag[0].split('-')[1];
                }
            }
            return "";
        };
        this.getServiceName = (serviceConf, id) => {
            this.logger.debug("getServiceName function");
            let serviceName = serviceConf.name;
            if (!id || id === "" || !serviceConf.dev || !serviceConf.dev.enable) {
                return serviceName;
            }
            let serviceNameList = serviceConf.dev.services;
            if (serviceNameList) {
                for (const value of serviceNameList) {
                    let idsList = value.ids;
                    if (idsList && idsList.indexOf(id) !== -1) {
                        serviceName = value.name ? value.name : serviceConf.name;
                        break;
                    }
                }
            }
            return serviceName;
        };
        this.logger.debug({ type: discoveryType });
    }
    dnsResolve(domainName, port, cb) {
        this.logger.info({ action: "dnsResolve", domainName: domainName });
        let loggerObj = this.logger;
        if (process.env.DNS_RES_TYPE && process.env.DNS_RES_TYPE == "resolve") {
            dns.resolve(domainName, rrtype, (err, records) => {
                if (err || !records) {
                    loggerObj.error(err);
                    cb(err ? err : "dns resolve failed for name: " + domainName, null);
                }
                else {
                    cb(null, records[0]);
                    loggerObj.info({ action: "dnsResolve", records: records });
                }
            });
            return;
        }
        //DEfault behavior!!!
        dns.lookup(domainName, function (err, record) {
            if (err || !record) {
                loggerObj.error({ action: "dnsResolve", err: err });
                cb(err ? err : "dns resolve failed for name: " + domainName, null);
            }
            else {
                cb(null, record);
                loggerObj.debug({ action: "dnsResolve", record: record });
            }
        });
    }
    getServicePorts(serviceType) {
        this.logger.debug("getServicePorts function");
        let serviceObject;
        switch (serviceType) {
            case ServiceType.MEDIA_GATEWAY: {
                serviceObject = mediaGwPorts;
                break;
            }
            case ServiceType.SIP_GATEWAY: {
                serviceObject = sipGwPorts;
                break;
            }
            case ServiceType.SIP_GATEWAY_NOTIFY: {
                serviceObject = sipNotifyGwPorts;
                break;
            }
            case ServiceType.MCU_STATS_SERVICE: {
                serviceObject = statsPorts;
                break;
            }
            case ServiceType.MCU_MONITOR_SERVICE: {
                serviceObject = monitorPorts;
                break;
            }
            case ServiceType.MCU_RECORDER_CONTROLLER: {
                serviceObject = recorderPorts;
                break;
            }
            case ServiceType.ETCD: {
                serviceObject = etcdPorts;
                break;
            }
            default: {
                serviceObject = {};
            }
        }
        this.logger.debug({ action: "getServicePorts", object: serviceObject });
        return serviceObject;
    }
    getService(serviceConf, id, cb) {
        this.logger.debug({ action: "getService", type: this.discoveryType, serviceConf: serviceConf });
        if (!serviceConf) {
            return cb("no service config file", null);
        }
        let serviceName = this.getServiceName(serviceConf, id);
        this.logger.info({ action: "getServiceName", name: serviceName });
        if (this.discoveryType === "dns") {
            let addressObject = this.getServicePorts(serviceConf.type);
            let domainSuffix = process.env.DOMAIN_SUFFIX ? process.env.DOMAIN_SUFFIX : serviceConf.domainSuffix;
            if (domainSuffix) {
                serviceName = serviceName + "." + domainSuffix;
            }
            addressObject.address = serviceName;
            return cb(null, addressObject);
        }
        let self = this;
        let ops = {
            query: serviceName,
            near: '_agent' /*return result in same data center, sorted by estimated round trip */,
            limit: 3 /*max results per query execution*/,
            timeOut: 750 /*ms*/
        };
        var options = {
            url: util.format("http://%s:%d%s/query/%s/execute", consul._opts.baseUrl.hostname, consul._opts.baseUrl.port, consul._opts.baseUrl.path, ops.query),
            headers: {
                'Content-Type': 'application/json'
            },
            timeout: 600
        };
        this.logger.info({ action: "Discovery", option: options });
        request.get(options, function (err, resp, body) {
            if (err || (resp.statusCode !== 200)) {
                self.logger.error({ error: "Failed to discover with options", options: options });
                return cb(err ? err : "Failed to discover service ", null);
            }
            else {
                let data = JSON.parse(body);
                //Randomly select a service from the returnd list (even though consul randomizes responses as well)
                //let serviceSelected = data.Nodes[Math.floor(Math.random() * data.Nodes.length)];
                let serviceSelected = data.Nodes[0]; //Get 1st service in list
                if (data.Nodes.length > 0) {
                    /*let result = {
                         id: serviceSelected.Service.ID,
                         serviceType: srvType,
                         container: {
                             address: serviceSelected.Service.Address,
                             thriftPort: self.getSrvThriftPort(serviceSelected.Service.Tags),
                             httpPort: serviceSelected.Service.Port,
                         }
                     };*/
                    let result = {
                        address: serviceSelected.Service.Address,
                        thriftPort: self.getSrvThriftPort(serviceSelected.Service.Tags),
                        httpPort: serviceSelected.Service.Port,
                    };
                    if (util.isNullOrUndefined(result.address) || serviceSelected.Node.Address === "") {
                        result.address = serviceSelected.Node.Address;
                    }
                    return cb(null, result);
                }
                else {
                    return cb("Service not found!!!", null);
                }
            }
        });
    }
}
exports.Discovery = Discovery;
