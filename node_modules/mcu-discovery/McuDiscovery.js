"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./lib/common");
const consul_1 = __importDefault(require("consul"));
const util_1 = __importDefault(require("util"));
const Register_1 = require("./Register");
const request = require("request-promise-native");
const getAddress_1 = require("./lib/getAddress");
const os_1 = __importDefault(require("os"));
const parseDuration_1 = __importDefault(require("./lib/parseDuration"));
const moment_1 = __importDefault(require("moment"));
const logger = global.logger || console;
const dns_lookup_cache_1 = require("dns-lookup-cache");
const decorator_1 = require("./lib/decorator");
exports.consulProtocol = "http";
exports.consulPort = "8500";
exports.consulUrl = "127.0.0.1";
exports.checkDeregister = "2s";
exports.checkType = "http";
exports.checkHttp = "/healthcheck";
exports.checkInterval = "10s";
exports.retryInterval = "3sec";
const sleep = util_1.default.promisify(setTimeout);
class McuDiscovery {
    constructor(options = {}) {
        this.logger = logger;
        this.debug = options.debug || false;
        this.register = (options.register !== false);
        //this.Discovery = new Discovery(this);
        this.Register = new Register_1.Register(this);
        this.serviceName = options.serviceName || process.env[common_1.SERVICE_NAME];
        this.serviceAddress = getAddress_1.getAddress() || "127.0.0.1";
        this.servicePort = options.servicePort || process.env[common_1.SERVICE_PORT];
        this.serviceUrl = (options.serviceUrl) ? options.serviceUrl : `http://${this.serviceAddress}:${options.checkPort ? options.checkPort : this.servicePort}`;
        this.serviceHost = options.serviceAddress || this.serviceAddress;
        if (!this.serviceName) {
            this.logger.info("Service Name missing not registering");
            this.register = false;
        }
        if (!this.servicePort) {
            this.logger.info("Service Port missing not registering");
            this.register = false;
        }
        const tags = options.serviceTags || process.env[common_1.SERVICE_TAGS] || "";
        this.serviceTags = tags.split(",");
        this.serviceMeta = {};
        if (this.serviceTags.length > 0) {
            this.serviceTags.forEach((tag) => {
                if (tag.indexOf("http") !== -1 || tag.indexOf("thrift") !== -1) {
                    this.serviceMeta[tag.split("-")[0]] = tag.split("-")[1];
                }
            });
        }
        this.checkType = options.checkType || process.env[common_1.SERVICE_CHECK_TYPE] || exports.checkType;
        this.checkHttp = options.checkHttp || process.env[common_1.SERVICE_CHECK_HTTP] || exports.checkHttp;
        this.checkDeregister = options.checkDeregister || process.env[common_1.SERVICE_CHECK_DEREGISTER_AFTER] || exports.checkDeregister;
        this.checkInterval = options.checkInterval || process.env[common_1.SERVICE_CHECK_INTERVAL] || exports.checkInterval;
        this.secure = options.secure || false;
        this.promisify = options.promisify || true;
        if (process.env.PLATFORM_TYPE && process.env.PLATFORM_TYPE === decorator_1.PLATFORM_TYPE_CONSUL) {
            this.findLeader().then(() => __awaiter(this, void 0, void 0, function* () {
                yield this.monitor();
            }));
        }
    }
    monitor() {
        return __awaiter(this, void 0, void 0, function* () {
            let dateNow;
            let lastRequest = moment_1.default().add(30, "seconds");
            (() => __awaiter(this, void 0, void 0, function* () {
                for (;;) {
                    this.logger.debug({ action: "monitor loop", active: this.consulActive, checkType: this.checkType, register: this.register });
                    if (this.consulActive && this.checkType === "ttl" && this.register) {
                        const serviceExists = yield this.serviceExists();
                        this.logger.debug(serviceExists);
                        if (serviceExists) {
                            this.logger.debug("exists");
                            yield this.Register.updateCheck(`service:${this.getServiceId()}`, "pass");
                        }
                        else {
                            this.logger.debug("doesnt exist");
                            yield this.registerService();
                        }
                    }
                    if (this.consulActive && this.checkType === "http" && this.register) {
                        dateNow = moment_1.default();
                        this.logger.debug(`Now: ${dateNow.format()} | Last request was at ${lastRequest.format()}`);
                        if (dateNow.diff(lastRequest, "seconds") > 30) {
                            const serviceExists = yield this.serviceExists();
                            if (!serviceExists) {
                                yield this.registerService();
                            }
                            lastRequest = moment_1.default();
                        }
                    }
                    yield sleep(parseDuration_1.default(exports.checkInterval));
                }
            }))();
        });
    }
    findLeader() {
        return __awaiter(this, void 0, void 0, function* () {
            const dev = false; //process.env.NODE_ENV !== "production";
            if (dev) {
                this.logger.debug("development mode: using 127.0.0.1");
                yield this.connect("127.0.0.1", "8500", "leader");
                yield this.connect("127.0.0.1", "8500");
                if (this.register) {
                    yield this.registerService();
                }
                return;
            }
            const consulLookup = yield this.lookup("consul.service.mcu.mavenir");
            if (consulLookup) {
                this.logger.debug("dns found, using consul");
                yield this.connect("consul.service.mcu.mavenir", "8500");
            }
            (() => __awaiter(this, void 0, void 0, function* () {
                for (;;) {
                    this.logger.debug("-- leader check --");
                    if (!this.consulActive) {
                        this.logger.debug("waiting for leader...");
                        const leader = yield this.checkConsul();
                        if (leader) {
                            logger.info(`leader is now ${leader}`);
                            yield this.connect(leader.split(":")[0], "8500", "leader");
                            if (this.register) {
                                this.logger.debug("-- registering... --");
                                yield this.registerService();
                            }
                        }
                    }
                    yield sleep(parseDuration_1.default(exports.retryInterval));
                }
            }))();
        });
    }
    getServiceId() {
        const port = this.servicePort;
        const name = this.serviceName;
        let portSuffix;
        if (port) {
            portSuffix = `:${port}`;
        }
        return `${name}@${os_1.default.hostname()}${portSuffix}`;
    }
    registerService() {
        return __awaiter(this, void 0, void 0, function* () {
            const id = this.getServiceId();
            const check = {
                id: `${id}_check`,
                name: `check_${id}`,
                deregistercriticalserviceafter: this.checkDeregister,
                notes: "Service Health Check",
                serviceid: id
            };
            if (this.checkType === "ttl") {
                check.ttl = "5s";
                check.interval = exports.checkInterval;
                check.status = "passing";
            }
            else {
                check.http = `${this.serviceUrl}${this.checkHttp}`;
                check.interval = exports.checkInterval;
            }
            const checkMetaData = {
                id,
                name: this.serviceName,
                address: this.serviceHost,
                port: Number(this.servicePort),
                tags: this.serviceTags,
                meta: this.serviceMeta,
                check
            };
            this.logger.debug(checkMetaData);
            yield this.Register.createService(checkMetaData);
        });
    }
    connect(hostname, port, type = "dns") {
        return __awaiter(this, void 0, void 0, function* () {
            const secure = this.secure;
            const promisify = this.promisify;
            const opts = {
                host: hostname,
                port: port,
                secure,
                promisify
            };
            const cls = consul_1.default(opts);
            if (type === "dns") {
                this.consul = cls;
            }
            else {
                this.consulActive = true;
                this.consulLeader = cls;
            }
        });
    }
    checkConsul() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { hostname, port, protocol, path } = this.consul._opts.baseUrl;
                const url = util_1.default.format("%s//%s:%s%s/status/leader", protocol, hostname, port, path);
                const response = yield request(url, { timeout: 2000 });
                return response.toString().replace(/"/g, "");
            }
            catch (e) {
                this.logger.error({ error: "failed to retrieve leader", err: e });
                return false;
            }
        });
    }
    lookup(address) {
        return new Promise((resolve, reject) => {
            dns_lookup_cache_1.lookup(address, { family: 4 }, (error, response) => {
                if (error) {
                    resolve(false);
                }
                else {
                    this.logger.debug({ action: "received dns response", response: response });
                    resolve(true);
                }
            });
        });
    }
    retry(methodName, methodFunction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.consulActive) {
                this.logger.debug("consul not active");
                return;
            }
            this.consulActive = false;
            yield this.findLeader();
        });
    }
    queryConsul() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const opts = {
                    query: this.serviceName,
                    near: "_agent",
                    limit: 3,
                    timeout: 750
                };
                return yield this.consulLeader.query.execute(opts);
            }
            catch (e) {
                if (this.debug) {
                    this.logger.debug({ error: e });
                }
                this.logger.debug("mcu-discovery: query consul failed");
            }
        });
    }
    serviceExists() {
        return __awaiter(this, void 0, void 0, function* () {
            let exists = false;
            const query = yield this.queryConsul();
            if (query) {
                const services = [];
                query.Nodes.forEach(node => {
                    this.logger.debug(`mcu-discovery: checking if ${node.Service.Address} is the same as ${this.serviceAddress}`);
                    if (node.Service.Address === this.serviceAddress || node.Service.Address === this.serviceHost) {
                        services.push({ ID: node.Service.ID, Address: node.Service.Address });
                    }
                });
                this.logger.debug(`Number of services from query: ${services.length}`);
                if (services.length !== 0) {
                    exists = true;
                }
            }
            return exists;
        });
    }
}
__decorate([
    decorator_1.notSupportedK8s()
], McuDiscovery.prototype, "monitor", null);
__decorate([
    decorator_1.notSupportedK8s()
], McuDiscovery.prototype, "findLeader", null);
__decorate([
    decorator_1.notSupportedK8s()
], McuDiscovery.prototype, "registerService", null);
__decorate([
    decorator_1.notSupportedK8s()
], McuDiscovery.prototype, "connect", null);
__decorate([
    decorator_1.notSupportedK8s()
], McuDiscovery.prototype, "checkConsul", null);
__decorate([
    decorator_1.notSupportedK8s()
], McuDiscovery.prototype, "retry", null);
__decorate([
    decorator_1.notSupportedK8s()
], McuDiscovery.prototype, "queryConsul", null);
__decorate([
    decorator_1.notSupportedK8s()
], McuDiscovery.prototype, "serviceExists", null);
exports.default = McuDiscovery;
