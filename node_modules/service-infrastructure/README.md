<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo_text.svg" width="320" alt="Nest Logo" /></a>
</p>

[travis-image]: https://api.travis-ci.org/nestjs/nest.svg?branch=master
[travis-url]: https://travis-ci.org/nestjs/nest
[linux-image]: https://img.shields.io/travis/nestjs/nest/master.svg?label=linux
[linux-url]: https://travis-ci.org/nestjs/nest
  
  <p align="center">A progressive <a href="http://nodejs.org" target="blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/dm/@nestjs/core.svg" alt="NPM Downloads" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://api.travis-ci.org/nestjs/nest.svg?branch=master" alt="Travis" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://img.shields.io/travis/nestjs/nest/master.svg?label=linux" alt="Linux" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#5" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec"><img src="https://img.shields.io/badge/Donate-PayPal-dc3d53.svg"/></a>
  <a href="https://twitter.com/nestframework"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[service-infrastructure](https://at.mavenir.com/bb/scm/mcu/service-infrastructure.git) 
service-infrastructure include MCU infrastructures:
1. common -
    1.1. Configuration-service - merge infrastructure, local, and k8s configmap configuration files.
    1.2. mculogger service
2. application - ApplicationService - handle uncaught exception and enabling resources monitor (cpu, memory and disk usage)
3. db - Persist API implementation.
4. get-version -  implemetation of get-version API
5. health - Healthcheck and IsReady http API, Probs list:
   CPU, Memory RSS, Disk-Space, Discovey, Thrift Client connection, EtcdConnection
6. pipes - validator pipe for automatically validate incoming requests  body/parameter vs predefined DTO.
7. CapacityException - TOO_MANY_REQUESTS excption
8. HttpExceptionFilter - Formating http body response (and logs) in case of http error response
9. interceptors - print http request and response (error/debug)
10. Thrift server start up
11. Thrift client - get client from connection pool
12. LoggerMiddleware - Loging request response for selected controller
13. Header Decoder (RequestHeader) - Anotation for rest header validation 


## Installation

```bash
$ npm install --save service-infrastructure
```
## Setup
It is highly recommended to enable shutdown hooks in your application
app.enableShutdownHooks();
```bash
    import { NestFactory } from '@nestjs/core';
    import { AppModule } from './app.module';
    
    async function bootstrap() {
      const app = await NestFactory.create(AppModule);
    
      // Starts listening for shutdown hooks
      app.enableShutdownHooks();
    
      await app.listen(3000);
    }
    bootstrap();

## Usage


```bash
Add all InfrastructureModule/Services to nest project:]
$ Open a new nest project
$ In the main module (app.module.ts) import InfrastructureModule: 

import {InfrastructureModule} from "service-infrastructure/infrastructure.module"
@Module ( {
      imports: [ InfrastructureModule  ],
      controllers: [   ],
      providers: [ ],
  } )
  export class AppModule {
  }
```


## Usage Example:

```bash
Note: in bleow example "project-name" is "nest-test-app"

create a new Nest project with the following commands in your OS terminal:
$ npm i -g @nestjs/cli
$ nest new nest-test-app

src/ directory will be created and populated with several core files.
    -> src
        -> app.controller.ts
        -> app.service.ts
        -> app.module.ts
        -> main.ts
 
cd to app.module.ts and add the "InfrastructureModule" in imports:
        
        import {InfrastructureModule} from "service-infrastructure/infrastructure.module"
        @Module ( {
            imports: [ InfrastructureModule ],
            controllers: [ AppController  ],
            providers: [AppService ],
        } )
        export class AppModule {
        }

For use the infrastructure in our controller/services we had register it on constructors, 
In below examples we using:
    in controller: the "Validator", "MculoggerService" and "ConfigurationService" services.
    in service: the "dbService" and  "ConfigurationService" services.


    app.controller.ts:

        import {Body, Controller, Get, Post, Put, UsePipes} from '@nestjs/common';
        import {AppService} from './app.service';
        import {Validator} from 'service-infrastructure/pipes/validation.pipe'
        import {MculoggerService} from "service-infrastructure/logs/mculogger.service";
        import {ConfigurationService} from "service-infrastructure/config/configuration.service"
        import {BodyDto} from "./dto/body.dto";
        
        @Controller ( 'test' )
        @UsePipes ( Validator )
        export class AppController {
            constructor(
                private readonly appService: AppService,
                private readonly logger: MculoggerService,
                private readonly configureService: ConfigurationService
            ) {
            }
        
            @Get ()
            getHello(): string {
                this.logger.info ( 'Http Get request' )
                this.logger.info(JSON.stringify(this.configureService.get('updateConfigurationInterval')))
                this.logger.info(this.configureService.get('db.etcd.port'))
                return this.appService.getHello ();
            }
        
            @Post()
            postMessage(@Body () bodyDto: BodyDto): string {
                this.logger.info ( `Http POST request BODY: ${JSON.stringify(bodyDto)}` )
                return
            }
        } 


    app.service.ts

        import {Injectable} from '@nestjs/common';
        import {DbService} from "service-infrastructure/db/db.service"
        import {ConfigurationService} from "service-infrastructure/config/configuration.service"
        
        @Injectable ()
        export class AppService {
            constructor(
                private readonly dbService: DbService,
                private readonly configurationService: ConfigurationService
            ) {
            }
        
            getHello(): string {
                let address = String ( this.configurationService.get ( 'db.etcd.host' ) );
                this.dbService.setRecord ( 'key', 'value', 3600 )
                return 'Hello World!';
            }
        }

    main

      import { AppModule } from './app.module';
        import {HttpExceptionFilter} from "service-infrastructure/filters/http-exception.filter";
        import {LoggingInterceptor} from "service-infrastructure/interceptors/logging.interceptor";
        import {NestFactory} from "@nestjs/core";
        import {NestExpressApplication} from "@nestjs/platform-express";
        import {MculoggerService} from "service-infrastructure/common/logs/mculogger.service";
        require ( "mcu-discovery" ) ( {serviceName: "mcu-setvice-name", servicePort: "3000"} ); // consul self registration
        
        
        const port: number = 3000
        
        async function bootstrap() {
            const app = await NestFactory.create<NestExpressApplication> ( AppModule, {
                // logger: false
            } );
        
            // let logger: MculoggerService = <MculoggerService>app.get ( MculoggerService )
            let httpExceptionFilter: HttpExceptionFilter = <HttpExceptionFilter>app.get ( HttpExceptionFilter )
            let loggingInterceptor: LoggingInterceptor = <LoggingInterceptor>app.get ( LoggingInterceptor )
        
            app.useGlobalFilters ( httpExceptionFilter )
            app.useGlobalInterceptors ( loggingInterceptor )
            app.enableShutdownHooks();
            await app.listen ( port );
        
        }
        
        bootstrap ()
            .then ( () => console.log ( 'Service Started Lisening on Port ' + port ) );

```
## Adding a healthchek prob:
Note:
It is required to adjust the following parameters, on configuration file (/config/config.json file has to defined  these parameters) in order to provide a proper monitor for the necessary resources: 
default value were set to:
          health : {
                readyThreshold: {
                    maxMemory: 2000, //Resident set size (RSS) is the portion of memory occupied by a process that is held in main memory (RAM) => const { rss } = process.memoryUsage();
                    maxDiskCapacity: 0.99, //Max disk allocation in precent (max 1)
                    cpuUsage: 0.3
                },
                healthyThreshold:{
                     maxMemory: 500,
                     maxDiskCapacity:0.8,
                     cpuUsage: 0.3
                }
              }


```bash
New monitor probs/monitor in local application:
the prob service shall extends HealthIndicator and implements IHealth
see example below:

        import { Injectable } from '@nestjs/common';
        import { HealthIndicator, HealthIndicatorResult, HealthCheckError } from '@nestjs/terminus';
        import {ProbType, IHealth} from "service-infrastructure/health/health.def";
        
        export interface Person {
            name: string;
            type: string;
        }
        
        @Injectable()
        export class AppHealthIndicator extends HealthIndicator implements IHealth {
        
            private probType: ProbType
            private persons: Person[] = [
                { name: 'Gerg', type: 'admin' },
                { name: 'Junatan', type: 'student' },
            ];
        
            constructor( ) {
                super ();
            }
        
            async check(): Promise<HealthIndicatorResult> {
                return await this.isHealthy('AppHealthIndicator')
            }
        
            setProbType(probType = ProbType.HEALTH): void {
                this.probType = probType
            }
        
            async isHealthy(key: string): Promise<HealthIndicatorResult> {
                const badpersons = this.persons.filter(person => person.type === 'badperson');
                const isHealthy = badpersons.length === 0;
                const result = this.getStatus(key, isHealthy, { badpersons: badpersons.length });
        
                if (isHealthy) {
                    return result;
                }
                throw new HealthCheckError('Appcheck failed', result);
            }
        }

2. In local application main module:
2.1 Add the local "prob" as a provider (AppHealthIndicator)
2.2 Implements OnModuleInit and set the local probs (As array) to healthService|readyService (healthService.setProbs)
2.3 Add the application name which "discovery" shall check  (this.discoveryService.setDiscoveyConf ( [ ServiceType.MCU_RECORDER_CONTROLLER ] ))
Notes: 
1. healthService" used for "helthcheck" probs api while "readyService" used for "isready" api.
2. the "ServiceType" is enum which defined in "mcu-discovery/Discovery" package

    for example:

        import {Module, OnModuleInit} from '@nestjs/common';
        import {AppController} from './app.controller';
        import {AppService} from './app.service';
        import {InfrastructureModule} from "service-infrastructure/infrastructure.module"
        import {AppHealthIndicator} from "./health/app.health";
        import {HealthService} from "service-infrastructure/health/health.service";
        import {ReadyService} from "service-infrastructure/health/ready.service"
        import {DiscoveryService} from "service-infrastructure/health/discovery/discovery.service";
        import {ServiceType} from "mcu-discovery/Discovery";
        import {ProbType} from "service-infrastructure/health/health.def";
        
        
        @Module ( {
            imports: [ InfrastructureModule ],
            controllers: [ AppController, ],
            providers: [ AppService, AppHealthIndicator ],
        } )
        export class AppModule implements OnModuleInit {
            constructor(private healthService: HealthService,
                        private  readyService: ReadyService,
                        private appHealthIndicator: AppHealthIndicator,
                        private discoveryService: DiscoveryService
            ) {
            }
        
            onModuleInit(): any {
            
               //Start Thrift server
                this.thriftServer.createThriftServer ( sipGwApi, this.testThriftService );
                this.thriftServer.start ();
        
                //discoveryService is prob from infrastructure module, so by default it was loaded to "isready" API ", so needed just defined an Array of applications for discovery verification
                this.discoveryService.setDiscoveyConf ( [ ServiceType.SIP_GATEWAY, ServiceType.MEDIA_GATEWAY, ServiceType.ETCD, ServiceType.MCU_RECORDER_CONTROLLER ] ) //add list of discovery applications
        
                //Thrift Prob definition
                this.thriftService.setThriftConf([{serviceType: ServiceType.SIP_GATEWAY, thriftServiceApi: sipGwApi}])
                
                //appHealthIndicator is a local prob
                this.healthService.setProbs ( [ this.appHealthIndicator ] ) //Adding probs for healthcheck API
                this.readyService.setProbs ( [ this.appHealthIndicator, this.thriftService ] ) //Adding provs for isReady API
            }
        }

```
## Using get thrift client from connection pool - exmpale

```bash
import {Injectable} from '@nestjs/common'
import * as SipTypes from "../../if/gen-nodejs/SipGwApi_types"
import {TransferNotificationDTO} from '../dto/transfer.notification.dto'
import {StopRecordNotificationDTO} from '../dto/stop.record.notification.dto'
import {SipNotificationResponseDTO} from "../dto/sip.notification.response.tdo";
import {ConfigurationService} from "service-infrastructure/common/config/configuration.service";
import {MculoggerService} from "service-infrastructure/common/logs/mculogger.service";
import {ServiceType} from "mcu-discovery/Discovery"
import {ThriftPoolService} from "service-infrastructure/thrift/clientPool/thrift.pool.service";
import * as SipGwApi from "../../if/gen-nodejs/SipGateway"
import {ThriftClient} from 'mcu-discovery/ThriftClient'


type ThriftResponseHandler = (err, response) => void;

interface SipNotification {
stopTransferNotify: (request: TransferNotificationDTO, handler: ThriftResponseHandler) => void;
stopRecordingNotify: (request: StopRecordNotificationDTO, handler: ThriftResponseHandler) => void;
}

@Injectable ()
export class SipNotificationService {

    constructor(private readonly logger: MculoggerService,
                private readonly configurationService: ConfigurationService,
                private readonly thriftPoolService: ThriftPoolService
    ) {
        this.logger.setContext ( SipNotificationService.name );
    }
    
        private async getSipClient(serviceType: ServiceType, thriftServiceApi: any): Promise<SipNotification> {
        try {
            let thriftClient: ThriftClient = <ThriftClient>await this.thriftPoolService.getConnection ( serviceType, thriftServiceApi )
            if (thriftClient && thriftClient.client) {
                return <SipNotification>thriftClient.client;
            } else {
                throw new Error ( "Failed to get thrift connection to sip-notify" );
            }
        } catch (e) {
            throw new Error ( e );
        }

    }

    public async notifyStopRecord(dto: StopRecordNotificationDTO): Promise<SipNotificationResponseDTO> {
        return new Promise<SipTypes.RecordingResponse> ( async (resolve, reject) => {
            let sipNotifyThriftClient: SipNotification
            try {
                sipNotifyThriftClient = <SipNotification>await this.getSipClient ( ServiceType.SIP_GATEWAY_NOTIFY, SipGwApi );
            } catch (e) {
                this.logger.error ( `[notifyStopRecord] ${e}` );
                return reject ( new Error ( e ) );
            }


            let notiyRequest: SipTypes.StopRecordingNotifyRequest = new SipTypes.StopRecordingNotifyRequest ();
            notiyRequest.roomId = dto.roomId;
            notiyRequest.meetingId = dto.meetingId;
            notiyRequest.recordId = dto.recordId;
            notiyRequest.recordLength = dto.recordLength;

            let status: SipTypes.RecordingStatus = new SipTypes.RecordingStatus ()
            status.statusCode = dto.status.statusCode;
            status.description = dto.status.description;
            notiyRequest.status = status


            this.logger.info ( `[notifyStopRecord] Build notiyRequest`, notiyRequest )

            try {

                sipNotifyThriftClient.stopRecordingNotify ( notiyRequest, (error: any, response: any) => {
                    if (error) {
                        this.logger.error ( `[notifyStopRecord] ${error.message}` );
                        return reject ( new Error ( error.message ) );
                    }
                    switch (response.status.statusCode) {
                        case SipTypes.ResponseStatusCode.OK: {
                            this.logger.info ( `[notifyStopRecord] stopRecordingNotify() response`, response );
                            // return resolve(new SipNotificationResponse(response));
                            return resolve ( response );
                        }
                        default: {
                            this.logger.error ( '[notifyStopRecord] stopRecordingNotify() response error => ', response );
                            return reject ( new Error ( 'stopRecordingNotify => ' + response.status.description ) );
                        }
                    }
                } );
            } catch (e) {
                this.logger.error ( `[notifyStopRecord] ${e}` )
                return reject ( new Error ( e ) )

            }
        } );
    }
}

```
## LoggerMiddleware usage - example
```bash
import {MiddlewareConsumer, Module, NestModule} from '@nestjs/common';
import {AppController} from './app.controller';
import {AppService} from './app.service';
import {InfrastructureModule} from "service-infrastructure/infrastructure.module";
import {LoggerMiddleware} from "service-infrastructure/middleware/logger.middleware";
import {HealthController} from "service-infrastructure/health/health.controller";

@Module ( {
    imports: [ InfrastructureModule ],
    controllers: [ AppController ],
    providers: [ AppService, TestThriftService , ThriftService],
} )
export class AppModule implements NestModule {
    constructor() {
    }

    configure(consumer: MiddlewareConsumer) {
        consumer.apply ( LoggerMiddleware ).forRoutes ( AppController,HealthController  );
    }
}

```
## Header Decoder - Example
```bash
  First defined an header TDO:
  
  import {IsAlphanumeric, IsBooleanString, IsNotEmpty, IsOptional, IsString, Matches} from "class-validator";

  export class RequestHeadersConferenceControlDto {
    @IsNotEmpty ()
    @IsAlphanumeric ()
    "p-mav-meeting-id": string | number
    @IsNotEmpty ()
    @IsAlphanumeric ()
    "x-client-id": string | number
    @IsNotEmpty ()
    @IsAlphanumeric ()
    "x-session-id": string | number
   }
   
   And used it in rest controller - validate header content:
   
   async controlConference(@Req() req: Request, @Body() body: ControlConferenceDto, @RequestHeader () headers: RequestHeadersConferenceControlDto)

```

## Support

NA

## Stay in touch
NA

## License
NA
 
