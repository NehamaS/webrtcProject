"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamicConfig = void 0;
const util_1 = require("util");
const _ = require("lodash");
const yaml = require("js-yaml");
const fs = require("fs");
const path = require("path");
const common_1 = require("@nestjs/common");
const mculogger_service_1 = require("../logs/mculogger.service");
const consul = require("consul");
const decorator_1 = require("mcu-discovery/lib/decorator");
let DynamicConfig = class DynamicConfig {
    constructor(logger) {
        this.logger = logger;
        this.updateConfigPeriodic = undefined;
        this.DEFAULT_UPDATE_CONF_INTERVAL = 60000;
        this.PLATFORM_TYPE = process.env.PLATFORM_TYPE || "k8s";
        this.CONF_PATH = process.env.CONF_PATH || '/opt/config-map.yaml';
        if (decorator_1.PLATFORM_TYPE_CONSUL === this.PLATFORM_TYPE) {
            this.startConsul();
        }
    }
    startConsul() {
        try {
            this.consulObjet = new consul({ host: process.env.EXT_IP, port: '8500', promisify: true });
            this.keyValueStore = this.consulObjet.kv;
            this.logger.info({ message: 'consul connected' });
        }
        catch (e) {
            this.logger.error({ msg: 'consul failure', error: e.message ? e.message : e });
        }
    }
    async updateConfig(confKey, servConf, automaticUpdateEnabled = true) {
        if (automaticUpdateEnabled) {
            this.autoUpdateConfig(confKey, servConf);
        }
        return await this.updateConf(confKey, servConf);
    }
    ;
    getKey(key, handler, processor) {
        this.logger.debug({ action: 'getKey', key: key });
        this.performKVapi(this.keyValueStore.get, [key], handler, processor);
    }
    getK8sConf(key, handler) {
        this.logger.debug({ action: 'getK8sConf', key: key });
        try {
            if (fs.existsSync(this.CONF_PATH)) {
                let ext = path.extname(this.CONF_PATH).substr(1);
                const file_contents = fs.readFileSync(this.CONF_PATH, { encoding: 'utf-8' });
                if (ext === 'yaml') {
                    const data = yaml.load(file_contents);
                    this.logger.debug({ action: `yaml.load`, dataType: `${typeof data}`, data: data });
                    return handler(undefined, JSON.stringify(data));
                }
                else if (ext === 'json') {
                    return handler(undefined, file_contents);
                }
                else {
                    this.logger.debug({ msg: 'unknown config file type', confPath: this.CONF_PATH });
                    return handler(Error(`unknown config file type for ${this.CONF_PATH}`), undefined);
                }
            }
            else {
                this.logger.error({ msg: 'config file not found', confPath: this.CONF_PATH });
                return handler(Error(`config file not found for ${this.CONF_PATH}`), undefined);
            }
        }
        catch (err) {
            this.logger.error({ error: err.message ? err.message : err });
            return handler(err, undefined);
        }
    }
    mergeConf(data, config) {
        if (data) {
            let prevCopy = config;
            _.merge(config, JSON.parse(data));
            if (!_.isEqual(config, prevCopy)) {
                this.logger.debug({
                    action: "dynamicConfig.updateConf",
                    description: "Configuration updated",
                    conf: config
                });
            }
        }
    }
    performKVapi(api, params, handler, processor) {
        let kvPromise = new Promise((resolve, reject) => {
            params.push((err, data) => {
                if (err) {
                    this.logger.error({ msg: 'Key value Store', error: err.message ? err.message : err });
                    reject(err);
                }
                else {
                    resolve(data);
                }
            });
            api.apply(this.keyValueStore, params);
        });
        kvPromise.then((value) => {
            if (value !== null && typeof value === 'object') {
                handler(undefined, value.Value, processor);
            }
            else {
                handler(undefined, value, processor);
            }
        }).catch((err) => {
            handler(err, undefined, processor);
        });
    }
    ;
    getKeys(parentKey, handler) {
        let kvPromise = new Promise((resolve, reject) => {
            this.keyValueStore.keys(parentKey, (err, data) => {
                if (err) {
                    this.logger.error({
                        action: 'getKeys',
                        msg: 'Key value Store error',
                        err: err.message ? err.message : err
                    });
                    reject(err);
                }
                else {
                    resolve(data);
                }
            });
        });
        kvPromise.then((data) => {
            let getAllKeys = new Array();
            data.forEach(key => {
                let getKey = new Promise((resolve, reject) => {
                    this.getKey(key, (error, result) => {
                        if (error) {
                            this.logger.error({
                                action: 'getKeys',
                                msg: 'Key value Store error',
                                error: error.message ? error.message : error
                            });
                            reject(error);
                        }
                        else {
                            resolve((0, util_1.format)('%s:%s', key, result));
                        }
                    });
                });
                getAllKeys.push(getKey);
            });
            Promise.all(getAllKeys).then((result) => {
                let data = new Array();
                result.forEach(entry => {
                    let kvStr = entry.split(':');
                    if (kvStr[0] !== parentKey) {
                        data.push({ key: kvStr[0], value: entry.slice(kvStr[0].length + 1) });
                    }
                });
                handler(undefined, data);
            });
        }).catch((error) => {
            this.logger.error({ error: error.message ? error.message : error });
            handler(error, undefined);
        });
    }
    ;
    autoUpdateConfig(confKey, servConf) {
        if (this.updateConfigPeriodic) {
            this.logger.debug({ action: 'autoUpdateConfig', enabled: true });
        }
        else {
            this.logger.info({ action: 'autoUpdateConfig', enable: true });
            this.updateConfigPeriodic = setInterval(async () => {
                let config = await this.updateConf(confKey, servConf);
                this.logger.debug({ action: 'autoUpdateConfig', config: config });
            }, process.env.UPDATE_CONF_INTERVAL ? parseInt(process.env.UPDATE_CONF_INTERVAL) : this.DEFAULT_UPDATE_CONF_INTERVAL);
        }
    }
    updateConf(confKey, servConf) {
        let self = this;
        self.logger.debug({ input: servConf });
        return new Promise((resolve, reject) => {
            if (_.isNil(confKey)) {
                this.logger.error({ msg: 'Merge file failed', error: 'confKey key is empty!!' });
                reject(new Error('Config key is empty!!'));
            }
            if ('k8s' === self.PLATFORM_TYPE) {
                this.getK8sConf(confKey, function (err, data) {
                    if (err) {
                        self.logger.error({ action: "dynamicConfig.updateConf.getK8sConf", error: err.message ? err.message : err });
                        return resolve(-1);
                    }
                    if (data) {
                        self.logger.debug({ action: "dynamicConfig.updateConf.getK8sConf", data: data });
                        self.mergeConf(data, servConf);
                        self.logger.debug({ action: 'Logs merge configuration', conf: servConf });
                        return resolve(servConf);
                    }
                    this.logger.info({
                        action: `dynamicConfig.updateConf`,
                        msg: `no new configuration provided, using default values`
                    });
                    return resolve(servConf);
                });
            }
            else {
                this.getKey(confKey, function (err, data) {
                    if (err) {
                        self.logger.error({ action: "dynamicConfig.updateConf.getKey", error: err.message ? err.message : err });
                        return resolve(-1);
                    }
                    if (data) {
                        self.logger.debug({ action: "dynamicConfig.updateConf.getKey", data: data });
                        self.mergeConf(data, servConf);
                        return resolve(servConf);
                    }
                    self.logger.info({
                        action: 'dynamicConfig.updateConf',
                        msg: 'no new configuration provided, using default values'
                    });
                    return resolve(servConf);
                });
            }
        });
    }
    onApplicationShutdown(signal) {
        if (this.updateConfigPeriodic) {
            this.updateConfigPeriodic.unref();
        }
    }
};
DynamicConfig = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [mculogger_service_1.MculoggerService])
], DynamicConfig);
exports.DynamicConfig = DynamicConfig;
//# sourceMappingURL=dynamic.config.service.js.map