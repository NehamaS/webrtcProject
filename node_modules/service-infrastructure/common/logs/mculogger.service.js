"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var MculoggerService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MculoggerService = void 0;
const common_1 = require("@nestjs/common");
const config_1 = require("@nestjs/config");
const logform_1 = require("logform");
const Queue = require("better-queue");
const { combine, timestamp, printf } = logform_1.format;
const MESSAGE = Symbol.for('message');
let MculoggerService = MculoggerService_1 = class MculoggerService extends common_1.ConsoleLogger {
    constructor(config) {
        super(MculoggerService_1.name);
        this.config = config;
        this.useLegacy = false;
        this.formatter = combine(timestamp(), logform_1.format.metadata({ fillExcept: ['message', 'level', 'timestamp', 'label'] }), printf((log) => {
            const { level, message, timestamp, metadata } = log;
            const stackReponse = (metadata.stack) ? `${metadata.stack.method} ${metadata.stack.filename} ${metadata.stack.line}` : '';
            let msg;
            if (message.length === 1) {
                msg = message[0];
            }
            else {
                msg = this.parseMsg(message, msg);
            }
            if (typeof msg === 'object') {
                msg = JSON.stringify(msg, this.getCircularReplacer());
            }
            return `${timestamp} ${level} ${msg} ${stackReponse}`;
        }));
        this.createQueue();
    }
    ;
    onApplicationBootstrap() {
        this.debug({ action: "logger started" });
    }
    async onModuleInit() {
        this.loggerDebug = this.config.get('logger.debug', false);
        this.logLevel = this.config.get('logger.level', 'info');
        this.loggerMethod = this.config.get('logger.method', 'queue');
        this.batchSize = this.config.get('logger.queue.batchSize', 5);
        this.batchDelay = this.config.get('logger.queue.batchDelay', 2000);
        this.batchDelayTimeout = this.config.get('logger.queue.batchDelayTimeout', 1000);
    }
    legacy() {
        this.useLegacy = true;
        return Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    }
    elapsed_time(note) {
        const precision = 3;
        const elapsed = process.hrtime(this.timingStart)[1] / 1000000;
        console.log(`${process.hrtime(this.timingStart)[0]} s ${elapsed.toFixed(precision)} ms ${note}  nano: ${process.hrtime(this.timingStart)[1]}`);
        this.timingStart = process.hrtime();
    }
    createQueue() {
        this.queue = new Queue((batch, cb) => {
            if (batch.level && batch.level != '') {
                const log = batch;
                if (log.args) {
                    if (log.level && this[log.level]) {
                        const stack = this.parse(log.stack);
                        const resp = this.formatter.transform({
                            level: log.level,
                            timestamp: log.timestamp,
                            message: log.args,
                            stack
                        });
                        console.log(resp[MESSAGE]);
                    }
                }
            }
            else {
                batch.forEach(log => {
                    console.log(`WTF`, log);
                    if (log.args) {
                        if (log.level && this[log.level]) {
                            const stack = this.parse(log.stack);
                            const resp = this.formatter.transform({
                                level: log.level,
                                timestamp: log.timestamp,
                                message: log.args,
                                stack
                            });
                            console.log(resp[MESSAGE]);
                        }
                    }
                });
            }
            cb();
        }, {
            batchSize: this.batchSize,
            batchDelay: this.batchDelay,
            batchDelayTimeout: this.batchDelayTimeout
        });
    }
    parseMsg(message, msg) {
        message.forEach((item, index) => {
            if (index === 0) {
                msg = (typeof item === 'object') ? item : { message: item };
            }
            else {
                if (typeof item === 'object') {
                    Object.assign(msg, item);
                }
            }
        });
        return msg;
    }
    parseNode(line) {
        const nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
        const parts = nodeRe.exec(line);
        if (!parts) {
            return null;
        }
        const filename = parts[2].split('.').slice(0, -1).join('.');
        const methodName = parts[1];
        if (methodName) {
            methodName.replace('Object.<anonymous>', filename).replace('Server.<anonymous>', filename);
        }
        return {
            file: parts[2].replace('Object.Module._', ''),
            methodName,
            arguments: [],
            lineNumber: +parts[3],
            column: parts[4] ? +parts[4] : null,
        };
    }
    parse(stackString) {
        const lines = stackString.split('\n');
        const parsedStack = lines.reduce((stack, line) => {
            const parseResult = this.parseNode(line);
            if (parseResult) {
                stack.push(parseResult);
            }
            return stack;
        }, []);
        if (this.loggerDebug) {
            console.log(`2 = ${parsedStack[2].methodName} ${parsedStack[2].file} ${parsedStack[2].lineNumber}`);
            console.log(`3 = ${parsedStack[3].methodName} ${parsedStack[3].file} ${parsedStack[3].lineNumber}`);
            console.log(`4 = ${parsedStack[4].methodName} ${parsedStack[4].file} ${parsedStack[4].lineNumber}`);
            console.log(`5 = ${parsedStack[5].methodName} ${parsedStack[5].file} ${parsedStack[5].lineNumber}`);
            console.log(`6 = ${parsedStack[6].methodName} ${parsedStack[6].file} ${parsedStack[6].lineNumber}`);
        }
        const stackLevel = 3;
        const stack = parsedStack[stackLevel];
        if (!stack)
            return false;
        const filename = stack.file;
        const line = stack.lineNumber;
        const column = stack.column;
        let method = stack.methodName;
        if (!method) {
            const stack2 = parsedStack[stackLevel + 1];
            method = stack2.methodName;
        }
        return { filename, line, method, column };
    }
    getStack() {
        const rawStack = new Error().stack;
        if (this.loggerMethod === 'queue') {
            return rawStack;
        }
        return this.parse(rawStack);
    }
    getCircularReplacer() {
        const seen = new WeakSet();
        return (key, value) => {
            if (typeof value === "object" && value !== null) {
                if (seen.has(value)) {
                    return;
                }
                seen.add(value);
            }
            return value;
        };
    }
    ;
    output(level, message) {
        const levels = { error: 0, warn: 1, info: 2, debug: 3, verbose: 4, };
        if (levels[level] > levels[this.logLevel]) {
            return;
        }
        if (this.loggerMethod === 'queue') {
            const timestamp = new Date().toISOString();
            this.queue.push({ level, args: message, stack: this.getStack(), timestamp, leg: this.useLegacy });
            return;
        }
        const stack = this.getStack();
        const resp = this.formatter.transform({
            level,
            message,
            stack
        });
        console.log(resp[MESSAGE]);
    }
    error(...args) {
        this.output('error', args);
    }
    info(...args) {
        this.output('info', args);
    }
    warn(...args) {
        this.output('warn', args);
    }
    debug(...args) {
        this.output('debug', args);
    }
    verbose(...args) {
        this.output('verbose', args);
    }
    update(config) {
        this.loggerMethod = (config.loggerMethod) ? config.loggerMethod : this.loggerMethod;
        this.logLevel = (config.logLevel) ? config.logLevel : this.logLevel;
        this.loggerDebug = (config.debug) ? config.debug : this.loggerDebug;
        if (config.queue) {
            this.batchSize = (config.queue.batchSize) ? config.queue.batchSize : this.batchSize;
            this.batchDelay = (config.queue.batchDelay) ? config.queue.batchDelay : this.batchDelay;
            this.batchDelayTimeout = (config.queue.batchDelayTimeout) ? config.queue.batchDelayTimeout : this.batchDelayTimeout;
        }
    }
};
MculoggerService = MculoggerService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [config_1.ConfigService])
], MculoggerService);
exports.MculoggerService = MculoggerService;
//# sourceMappingURL=mculogger.service.js.map