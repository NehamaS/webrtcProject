"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsService = exports.CounterType = void 0;
const common_1 = require("@nestjs/common");
const hot_shots_1 = require("hot-shots");
const mculogger_service_1 = require("../common/logs/mculogger.service");
const _ = require("lodash");
var CounterType;
(function (CounterType) {
    CounterType["gaugeCounter"] = "gaugeCounter";
    CounterType["incrementCounter"] = "incrementCounter";
    CounterType["decrementCounter"] = "decrementCounter";
    CounterType["setCounter"] = "setCounter";
    CounterType["distributionCounter"] = "distributionCounter";
    CounterType["histogramCounter"] = "histogramCounter";
    CounterType["timing"] = "timing";
})(CounterType = exports.CounterType || (exports.CounterType = {}));
let MetricsService = class MetricsService {
    constructor(metrics, logger) {
        this.metrics = metrics;
        this.logger = logger;
    }
    setClient(options) {
        return this.metrics.childClient(options);
    }
    incrementCounter(incCounterInfo) {
        const counterInfo = _.merge(incCounterInfo, { vale: 1 });
        this.metrics.increment(counterInfo.counterName, 1, this.setTags(counterInfo), (error, bytes) => {
            this.analyze(error, bytes, CounterType.incrementCounter, counterInfo.counterName);
        });
    }
    decrementCounter(incCounterInfo) {
        const counterInfo = _.merge(incCounterInfo, { vale: 1 });
        this.metrics.decrement(counterInfo.counterName, 1, this.setTags(counterInfo), (error, bytes) => {
            this.analyze(error, bytes, CounterType.decrementCounter, counterInfo.counterName);
        });
    }
    gaugeCounter(counterInfo) {
        this.metrics.gauge(counterInfo.counterName, counterInfo.value, this.setTags(counterInfo), (error, bytes) => {
            this.analyze(error, bytes, CounterType.gaugeCounter, counterInfo.counterName);
        });
    }
    setCounter(counterInfo) {
        this.metrics.set(counterInfo.counterName, counterInfo.value, this.setTags(counterInfo), (error, bytes) => {
            this.analyze(error, bytes, CounterType.setCounter, counterInfo.counterName);
        });
    }
    distribution(counterInfo, callback) {
        this.metrics.distribution(counterInfo.counterName, counterInfo.value, this.setTags(counterInfo), (error, bytes) => {
            this.analyze(error, bytes, CounterType.distributionCounter, counterInfo.counterName);
        });
    }
    histogram(counterInfo, callback) {
        this.metrics.histogram(counterInfo.counterName, counterInfo.value, this.setTags(counterInfo), (error, bytes) => {
            this.analyze(error, bytes, CounterType.histogramCounter, counterInfo.counterName);
        });
    }
    timing(counterInfo, callback) {
        this.metrics.timing(counterInfo.counterName, counterInfo.value, this.setTags(counterInfo), (error, bytes) => {
            this.analyze(error, bytes, CounterType.timing, counterInfo.counterName);
        });
    }
    clientCheck() {
        this.metrics.check('service.up', this.metrics.CHECKS.OK, {
            hostname: "localhost",
            message: "is connect?"
        }, [], (error, bytes) => {
            if (error) {
                this.logger.error({ action: 'clientCheck', error: error.message });
            }
        });
    }
    clientClose() {
        this.metrics.close((error) => {
            if (error) {
                this.logger.error({ action: 'clientClose', error: error.message });
            }
        });
    }
    analyze(error, bytes, counterType, counterName) {
        if (error) {
            const err = {
                counterType: counterType,
                counter: counterName,
                error: error.message
            };
            this.logger.warn(err);
        }
        else {
            const message = {
                counterType: counterType,
                counter: counterName,
                bytes: bytes
            };
            this.logger.verbose(message);
        }
    }
    setTags(counterInfo) {
        return _.merge({
            organizationId: counterInfo.organizationId,
            accountId: counterInfo.accountId,
            appSid: counterInfo.appSid
        }, counterInfo.tag);
    }
};
MetricsService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [hot_shots_1.StatsD,
        mculogger_service_1.MculoggerService])
], MetricsService);
exports.MetricsService = MetricsService;
//# sourceMappingURL=metrics.service.js.map