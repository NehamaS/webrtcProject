"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Register = exports.Registry = void 0;
const util_1 = require("./util");
const persistFactory_1 = require("mcu-persitence-service/persistance/persistFactory");
const persist_1 = require("mcu-persitence-service/persistance/persist");
const common_1 = require("mcu-persitence-service/common/common");
const logger = global.logger || console;
class Registry {
    constructor() {
        this.prefix = process.env.SERVICE_NAME || 'metrics|';
        this._metrics = new Array();
        this._defaultLabels = {};
        this.ttl = 86400;
        if (global.db) {
            this.db = global.db;
        }
        else {
            const options = {
                prefix: process.env.SERVICE_NAME || 'MCU_METRICS',
                type: common_1.DBType.INMEM
            };
            const factory = new persistFactory_1.PersistFactory(logger, options);
            this.db = new persist_1.Persist(logger, options, factory);
        }
    }
    setDB(db) {
        if (db) {
            this.db = db;
        }
        else {
            let message = "metrics can't working, db isn't defined";
            logger.error({ action: 'setDB failed', message: message });
            throw new Error(message);
        }
    }
    async update(name, options) {
        name = `${this.prefix}${name}`;
        await this.db.put(name, options);
    }
    async remove(name) {
        await this.db.remove(`${this.prefix}${name}`);
    }
    async getValue(name) {
        const metric = await this.db.get(`${this.prefix}${name}`);
        if (typeof metric === 'string') {
            const result = JSON.parse(metric);
            return parseFloat(result.value);
        }
        else {
            return 0;
        }
    }
    setDefaultLabels(labels) {
        this._defaultLabels = labels;
    }
    async getSingleMetric(name) {
        try {
            const metric = await this.db.get(name);
            return metric;
        }
        catch (e) {
            logger.error({ action: 'getSingleMetric', error: e.message });
            throw new Error(e.message);
        }
    }
    async getMetricsAsArray() {
        try {
            const metrics = await this.db.itemsByPrefix(`${this.prefix}`);
            return Object.values(metrics);
        }
        catch (e) {
            logger.error({ action: 'getMetricsAsArray', error: e.message });
            throw new Error(e.message);
        }
    }
    async getMetricAsPrometheusString(item) {
        const name = (0, util_1.escapeString)(item.name);
        const help = `# HELP ${name} ${(0, util_1.escapeString)(item.help)}`;
        const type = `# TYPE ${name} ${item.type}`;
        const defaultLabelNames = Object.keys(this._defaultLabels);
        let values = '';
        item.labels = item.labels || {};
        if (defaultLabelNames.length > 0) {
            item.labels = Object.assign({}, item.labels);
            for (const labelName of defaultLabelNames) {
                item.labels[labelName] =
                    item.labels[labelName] || this._defaultLabels[labelName];
            }
        }
        let metricName = item.name;
        const keys = Object.keys(item.labels);
        const size = keys.length;
        if (size > 0) {
            let labels = '';
            let i = 0;
            for (; i < size - 1; i++) {
                labels += `${keys[i]}="${(0, util_1.escapeLabelValue)(item.labels[keys[i]])}",`;
            }
            labels += `${keys[i]}="${(0, util_1.escapeLabelValue)(item.labels[keys[i]])}"`;
            metricName += `{${labels}}`;
        }
        values += `${metricName} ${(0, util_1.getValueAsString)(item.value)}\n`;
        return `${help}\n${type}\n${values}`.trim();
    }
    async metrics() {
        try {
            const promises = new Array();
            let metricArr = await this.getMetricsAsArray();
            for (const _metric of metricArr) {
                promises.push(this.getMetricAsPrometheusString(_metric));
            }
            const resolves = await Promise.all(promises);
            return `${resolves.join('\n\n')}\n`;
        }
        catch (e) {
            logger.error({ action: 'metrics', error: e.message });
            throw new Error(e.message);
        }
    }
}
exports.Register = Registry;
const registry = new Registry();
exports.Registry = registry;
//# sourceMappingURL=registry.js.map