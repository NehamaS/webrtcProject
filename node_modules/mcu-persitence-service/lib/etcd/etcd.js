"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EtcdDB = exports.calcAddress = void 0;
const etcd3_1 = require("etcd3");
const util_1 = require("util");
const common_1 = require("../../common/common");
const Discovery_1 = require("mcu-discovery/Discovery");
const calcAddress = (options) => {
    if (process.env.ETCD_ADDR) {
        return process.env.ETCD_ADDR;
    }
    if (options.discoveryConfig) {
        let discoveryConf = options.discoveryConfig.config;
        return discoveryConf.domainSuffix && discoveryConf.domainSuffix != "" ? `${discoveryConf.name}.${discoveryConf.domainSuffix}` : discoveryConf.name;
    }
    if (options.dbConfig && options.dbConfig.host) {
        return options.dbConfig.host;
    }
    return options.address;
};
exports.calcAddress = calcAddress;
class EtcdDB extends common_1.DB {
    constructor(logger, options) {
        super(options.prefix);
        this.logger = logger;
        this.options = options;
        this.discovery = {};
        this.refreshConnTimer = undefined;
        /**
         *
         * @param key string, => actual key = 'this.prefix/key'
         * @param value string or object (will be serialized)
         * @param ttl number in seconds or date object. Value must be at least 1 sec in the future
         */
        this.put = async (key, value, ttl) => {
            // if (!this.db ){
            //     await this.refreshConnection();
            // }
            let val = value;
            if (!util_1.isString(key)) {
                this.logger.error('db put: wrong key type');
                return false;
            }
            if (!util_1.isString(val)) {
                val = JSON.stringify(value);
            }
            if (ttl) {
                let ttlNumber;
                if (ttl instanceof Date) {
                    ttlNumber = (ttl.getTime() - Date.now()) / 1000;
                }
                else {
                    ttlNumber = ttl;
                }
                this.logger.debug({ action: 'etcd', lease: this.getKey(key), ttl: ttlNumber });
                let lease = this.db.lease(ttlNumber);
                await lease.put(this.getKey(key)).value(val);
                lease.release();
            }
            else {
                //No ttl
                await this.db.put(this.getKey(key)).value(val);
            }
            return true;
        };
        this.get = async (key) => {
            let res = await this.db.get(this.getKey(key));
            if (res instanceof String) {
                if (res[0] === '{') {
                    res = JSON.parse(res);
                }
            }
            return res;
        };
        this.range = async (rng) => {
            let rangeQry = rng.start ? { start: rng.start, end: rng.end } : rng.prefix;
            //length ('':SS') = 3 => remove the seconds, use only filter by min
            let rangeRequest = {
                key: Buffer.from(this.getKey(`${rng.prefix}/${rng.start}`).slice(0, -3).trim()),
                range_end: Buffer.from(this.getKey(`${rng.prefix}/${rng.end}`).slice(0, -3).trim())
            };
            if (process.env.DEBUG_FUUL_DAY) {
                //length ('HH:mm:SS') = 8
                rangeRequest = {
                    key: Buffer.from(this.getKey(`${rng.prefix}/${rng.start}`).slice(0, -8).trim() + ':00:01'),
                    range_end: Buffer.from(this.getKey(`${rng.prefix}/${rng.end}`).slice(0, -8).trim() + ':23:59')
                };
            }
            let res = await this.db.kv.range(rangeRequest);
            let result = res.kvs.map((kv) => {
                try {
                    return JSON.parse(kv.value.toString());
                }
                catch (e) {
                    return kv.value;
                }
            });
            return result;
        };
        this.rangeByPrefix = async (keyPrefix) => {
            let entries = await this.db.getAll().prefix(this.getKey(keyPrefix));
            let keys = Object.keys(entries);
            let result = keys.map((key, ix) => {
                let record;
                try {
                    record = JSON.parse(entries[key]);
                }
                catch (e) {
                    record = entries[key];
                }
                return record;
            });
            return result;
        };
        this.remove = async (key) => {
            await this.db.delete().key(this.getKey(key));
            return true;
        };
        let address = exports.calcAddress(options);
        let dbOptions = { hosts: util_1.format('%s:%d', address, options.port) };
        logger.debug(dbOptions);
        try {
            this.db = new etcd3_1.Etcd3(dbOptions);
        }
        catch (e) {
            this.logger.error({ action: 'Etcd3', error: e.message ? e.message : e, dbOptions });
        }
        if (options.refreshInterval && options.refreshInterval > 0) {
            logger.debug({ action: "enable ETCD connection refresh", interval: options.refreshInterval });
            this.refreshConnTimer = setInterval(this.refreshConnection.bind(this) /*give access to 'this'*/, options.refreshInterval * 1000);
        }
    }
    getDiscovery() {
        this.discovery = this.discovery["getService"] ? this.discovery : new Discovery_1.Discovery(this.options.discoveryConfig ? this.options.discoveryConfig.type : "dns", this.logger);
        return this.discovery;
    }
    async refreshConnection() {
        let self = this;
        this.logger.debug("Refresh ETCD connection");
        return new Promise((resolve) => {
            if (self.options.discoveryConfig) {
                let discovery = this.getDiscovery();
                // @ts-ignore
                discovery.getService(self.options.discoveryConfig.config, '', (err, discoveryResult) => {
                    self.logger.debug({
                        action: 'refresh ETCD connection',
                        discovery: true,
                        override: process.env.ETCD_ADDR ? process.env.ETCD_ADDR : 'N/A',
                        options: self.options
                    });
                    if (err) {
                        self.logger.warn({ action: 'Failed to discover ETCD (not replacing etcd connection :-( )', error: err });
                        //DO NOT replace existing etcd connection
                        return resolve();
                    }
                    self.logger.debug(discoveryResult);
                    let dbOptions = { hosts: util_1.format('%s:%d', discoveryResult.address, discoveryResult.httpPort) };
                    this.renewConnection(dbOptions);
                    return resolve();
                });
            }
            else {
                self.logger.debug({
                    action: 'refresh ETCD connection...',
                    discovery: false,
                    override: process.env.ETCD_ADDR ? process.env.ETCD_ADDR : 'N/A',
                    options: self.options
                });
                let address = exports.calcAddress(self.options);
                let dbOptions = { hosts: util_1.format('%s:%d', address, self.options.dbConfig ? self.options.dbConfig.port : self.options.port) };
                this.renewConnection(dbOptions);
                return resolve();
            }
        });
    }
    renewConnection(dbOptions) {
        let self = this;
        try {
            self.logger.debug({ action: 'renewConnection', dbOptions });
            self.db = new etcd3_1.Etcd3(dbOptions);
        }
        catch (e) {
            this.logger.error({ action: 'renewConnection', error: e.message ? e.message : e, dbOptions });
        }
    }
}
exports.EtcdDB = EtcdDB;
//# sourceMappingURL=etcd.js.map